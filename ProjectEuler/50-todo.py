N = 1_000_000

spf = [i for i in range(N + 1)]
primes = []
for i in range(2, N + 1):
    if spf[i] == i:
        primes.append(i)
    for p in primes:
        if i * p > N:
            break
        spf[i * p] = p
        if i % p == 0:
            break

print(len(primes))  # 1000000 以内共 78498 个质数

# 方法一：筛法
# 检查所有质数连续和（从长到短），一旦找到和为素数的情况，即为答案
# 最坏时间复杂度 O(n^2)：78498 ** 2 = 6161936004

# 方法二：逐个检查
# 检查所有素数，求出其对应的最长质数连续和
# 使用双指针可以在 O(n) 的时间内找到可行解
# 时间复杂度 O(n^2)

# 方法一看起来更有希望一点。
# 跑了五分钟没什么反应。

# 方法三？
# 为了得到高效的算法，需要对原问题进行更加细致的观察
# 首先，对于某个素数，其连续素数和的分解方案是唯一的吗？
# 对于求和个数相同的情况，显然是唯一的，但个数不同时就不一定了
# 可能是个数较多，但数值偏小，也可能是个数较少，但数值偏大
# ……
# 这个问题的本质是什么？
# 从一个数组中，找出最长的子数组，满足该子数组的元素和，是该数组中的某个元素
# n = 1e5
# 根据题目要求，子数组长度至少为 22
# 因此需要遍历的素数并没有 78498 个，可以去掉较大的素数

pass
